from openravepy import *
from scipy import spatial
import igraph as ig
import MotionFunctions as mf
import Kinematics as kin
import numpy as np

# six angles and one velocity parameter
_STATE_LEN = 7

# return the configuration of the given state
def get_cfg(state):
    return state[:5]
# return the velocity of the given state
def get_v(state):
    return state[6]

# general hints
# - why? saves a lot of inverse kinematic calculation time
# - use inverse kinematics for the obstacles to transform them into c space

# input:
# - g: graph to plot
# - layout: plot layout algorithm
def plot_igraph(graph, layout):
    visual_style = {}
    visual_style["vertex_size"] = 20
    #visual_style["vertex_color"] = [color_dict[gender] for gender in g.vs["gender"]]
    visual_style["vertex_label"] = graph.vs["name"]
    #visual_style["edge_width"] = [1 + 2 * int(is_formal) for is_formal in g.es["is_formal"]]
    visual_style["layout"] = layout
    visual_style["bbox"] = (600,600)
    visual_style["margin"] = 20
    ig.plot(graph, **visual_style)
    return



# input:
# - robot:
# - configuration: configuration to be checked
# output:
# - boolean whether configuration is valid (in free space)
def is_valid(robot, configuration):
    configuration_backup = robot.GetDOFValues()
    robot.SetDOFValues(configuration)
    report = CollisionReport()
    inlier = robot.GetEnv().CheckCollision(robot,report)
    contact_count = len(report.contacts)
    contact_count = contact_count + 1 if robot.CheckSelfCollision() else contact_count
    robot.SetDOFValues(configuration_backup)
    return len(report.contacts) < 1



# input:
# - robot:
# output:
# - random configuration in the configuration space
def generate_random_configuration(robot):
    lower,upper = robot.GetDOFLimits()
    angular_limits_difference = upper - lower
    valid = False
    while valid == False:
        configuration_random = lower + np.random.sample(len(lower)) * angular_limits_difference
        valid = is_valid(robot, configuration_random)
    return configuration_random



# input:
# - state:
# - graph:
# output:
# - the nearest configuration
# - the index of the vertex of the nearest configuration
# find the nearest neighbor of a (random) state about to be inserted into the graph
def find_nearest_neighbor(state, graph):
    search_structure = spatial.KDTree(graph.vs["configuration"])
    # search for smallest euclidean distance between configurations
    distance, state_near_idx = search_structure.query(get_cfg(state),1);
    state_near = np.append(graph.vs["configuration"][state_near_idx],graph.vs["velocity"][state_near_idx])
    return state_near,state_near_idx



# input:
# - state_init:
# - state_goal:
# output:
# - minimal input to reach the state_goal from the state_init
def select_input(state_init, state_goal):
    #difference = np.fabs(mf.difference_rel(start_cfg, target_cfg))
    #velocity_limit, acceleration_limit, times_acc, times_dec, times_end = mf.limits_and_times(robot, difference, 'F')
    #velocity_limit, acceleration_limit, times_acc, times_dec, times_end = mf.discretize(difference, velocity_limit, acceleration_limit, times_acc, times_dec, times_end)
    input_u = 0.0
    return input_u



# input:
# - state_init:
# - input_u:
# - delta_time:
# output:
# - new state generated by the given state_init and input
def generate_state(state_init, input_u, delta_time):
    state_new = np.zeros(_STATE_LEN)
    return state_new



# input:
# - state: state to insert into the graph
# - graph: the corresponding graph
# output:
# - index of the new vertex
def insert_state(state, graph):
    graph.add_vertex()
    idx = graph.vcount()-1
    vertex = graph.vs[idx]
    vertex["name"] = idx
    vertex["configuration"] = get_cfg(state)
    vertex["velocity"] = get_v(state)
    return idx



# input:
# - robot: instance of the robot
# - vertex_count: number of vertices k
# - delta_time: incremental distance
# output:
# - rt graph g
def generate_rt(robot, target_cfg, vertex_count, delta_time):
    # create initial & goal state for the rrt algorithm
    velocity = 0.0
    state_init = np.append(robot.GetDOFValues(),velocity)
    print 'state_init:',state_init,'- len:',len(state_init)
    state_goal = np.append(target_cfg,velocity)
    print 'state_goal:',state_goal,'- len:',len(state_goal)
    
    # create graph structure with initial state
    g = ig.Graph()
    state_init_idx = insert_state(state_init,g)
    
    # entire rt generation algorithm as in [Lav98c]
    for i in range(1, vertex_count):
        state_random = generate_random_configuration(robot)
        state_near,state_near_idx = find_nearest_neighbor(state_random, g)
        input_u = select_input(state_near, state_random)
        state_new = generate_state(state_near, input_u, delta_time)
        state_new_idx = insert_state(state_new,g)
        # add edge and assign input_u as an attribute
        g.add_edge(state_near_idx, state_new_idx)
        g.es[g.ecount()-1]["input_u"] = input_u
    
    plot_igraph(g, g.layout_kamada_kawai())

    return g



def rrt(robot, target_cfg):
    vertex_count = 100
    delta_time = None
    rt = generate_rt(robot, target_cfg, vertex_count, delta_time)


